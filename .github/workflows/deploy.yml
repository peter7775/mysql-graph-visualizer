name: Deploy

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types: [completed]
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      image_tag:
        description: 'Docker image tag (leave empty for latest)'
        required: false
        type: string
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Determine deployment parameters
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    if: |
      (github.event.workflow_run.conclusion == 'success' && 
       contains(fromJson('["main", "develop"]'), github.event.workflow_run.head_branch)) ||
      github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.params.outputs.environment }}
      image_tag: ${{ steps.params.outputs.image_tag }}
      image_url: ${{ steps.params.outputs.image_url }}
      skip_tests: ${{ steps.params.outputs.skip_tests }}
      should_deploy: ${{ steps.params.outputs.should_deploy }}
    steps:
      - name: Determine deployment parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual deployment
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
            SKIP_TESTS="${{ github.event.inputs.skip_tests }}"
          else
            # Automatic deployment based on branch
            if [ "${{ github.event.workflow_run.head_branch }}" = "main" ]; then
              ENVIRONMENT="production"
            else
              ENVIRONMENT="staging"
            fi
            IMAGE_TAG=""
            SKIP_TESTS="false"
          fi
          
          # Determine image tag
          if [ -z "$IMAGE_TAG" ]; then
            IMAGE_TAG="${{ github.event.workflow_run.head_sha || github.sha }}"
          fi
          
          IMAGE_URL="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG"
          
          # Deployment logic
          SHOULD_DEPLOY="true"
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_url=$IMAGE_URL" >> $GITHUB_OUTPUT
          echo "skip_tests=$SKIP_TESTS" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          
          echo "Deployment Parameters:"
          echo "  Environment: $ENVIRONMENT"
          echo "  Image Tag: $IMAGE_TAG"
          echo "  Image URL: $IMAGE_URL"
          echo "  Skip Tests: $SKIP_TESTS"

  # Pre-deployment tests
  pre-deployment-tests:
    name: Pre-deployment Tests
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should_deploy == 'true' && needs.prepare.outputs.skip_tests == 'false'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Docker image exists
        run: |
          echo "Verifying Docker image exists: ${{ needs.prepare.outputs.image_url }}"
          
          # Try to pull the image
          if docker pull "${{ needs.prepare.outputs.image_url }}"; then
            echo "Docker image found and pulled successfully"
          else
            echo "Docker image not found: ${{ needs.prepare.outputs.image_url }}"
            echo "Available tags:"
            docker search "${{ env.IMAGE_NAME }}" || true
            exit 1
          fi

      - name: Run container smoke tests
        run: |
          echo "Running container smoke tests..."
          
          # Run container in detached mode
          CONTAINER_ID=$(docker run -d \
            --name test-container \
            -p 8080:8080 \
            -p 3000:3000 \
            -e LOG_LEVEL=info \
            "${{ needs.prepare.outputs.image_url }}")
          
          echo "Container ID: $CONTAINER_ID"
          
          # Wait for container to start
          echo "Waiting for application to start..."
          sleep 30
          
          # Check if container is running
          if ! docker ps | grep -q "$CONTAINER_ID"; then
            echo "Container failed to start"
            docker logs "$CONTAINER_ID"
            exit 1
          fi
          
          echo "Container is running"
          
          # Test health endpoint (if available)
          for i in {1..30}; do
            if curl -f http://localhost:8080/api/health > /dev/null 2>&1; then
              echo "Health check passed"
              break
            fi
            echo "Attempt $i/30: Health check failed, retrying..."
            sleep 2
          done
          
          # Cleanup
          docker stop "$CONTAINER_ID"
          docker rm "$CONTAINER_ID"
          
          echo "Smoke tests completed successfully"

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [prepare, pre-deployment-tests]
    if: |
      always() &&
      needs.prepare.outputs.should_deploy == 'true' &&
      needs.prepare.outputs.environment == 'staging' &&
      (needs.pre-deployment-tests.result == 'success' || needs.prepare.outputs.skip_tests == 'true')
    environment:
      name: staging
      url: https://mysql-graph-visualizer-staging.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup deployment tools
        run: |
          echo "Setting up deployment tools..."
          # Install deployment tools (kubectl, helm, docker-compose, etc.)
          # This is where you'd install your specific deployment tools
          
      - name: Configure staging environment
        run: |
          echo "Configuring staging environment..."
          # Configure staging environment variables, secrets, etc.
          # This is environment-specific configuration
          
      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."
          echo "Image: ${{ needs.prepare.outputs.image_url }}"
          
          # Example Docker Compose deployment
          cat > docker-compose.staging.yml << EOF
          version: '3.8'
          services:
            mysql-graph-visualizer:
              image: ${{ needs.prepare.outputs.image_url }}
              ports:
                - "3000:3000"
                - "8080:8080"
              environment:
                - LOG_LEVEL=info
                - GO_ENV=staging
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/api/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
            
            mysql:
              image: mysql:8.0
              environment:
                MYSQL_ROOT_PASSWORD: staging-password
                MYSQL_DATABASE: mysql_graph_visualizer
              volumes:
                - mysql_data:/var/lib/mysql
              restart: unless-stopped
            
            neo4j:
              image: neo4j:4.4
              environment:
                NEO4J_AUTH: neo4j/staging-password
                NEO4J_ACCEPT_LICENSE_AGREEMENT: 'yes'
              ports:
                - "7474:7474"
                - "7687:7687"
              volumes:
                - neo4j_data:/data
              restart: unless-stopped
          
          volumes:
            mysql_data:
            neo4j_data:
          EOF
          
          # Deploy using docker-compose (example)
          # In real deployment, you might use Kubernetes, Docker Swarm, or other tools
          echo "Deployment configuration generated"
          cat docker-compose.staging.yml
          
          # Example deployment command (customize based on your infrastructure)
          # docker-compose -f docker-compose.staging.yml up -d
          
          echo "Staging deployment completed"

      - name: Post-deployment verification
        run: |
          echo "Verifying staging deployment..."
          
          # Wait for application to be ready
          echo "Waiting for application to be ready..."
          sleep 60
          
          # Test staging endpoints
          STAGING_URL="https://mysql-graph-visualizer-staging.example.com"
          
          # Basic connectivity test
          if curl -f "$STAGING_URL/api/health" > /dev/null 2>&1; then
            echo "Staging health check passed"
          else
            echo "Staging health check failed (this might be expected if URL is not configured)"
          fi
          
          echo "Staging deployment verification completed"

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [prepare, pre-deployment-tests]
    if: |
      always() &&
      needs.prepare.outputs.should_deploy == 'true' &&
      needs.prepare.outputs.environment == 'production' &&
      (needs.pre-deployment-tests.result == 'success' || needs.prepare.outputs.skip_tests == 'true')
    environment:
      name: production
      url: https://mysql-graph-visualizer.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure production environment
        run: |
          echo "Configuring production environment..."
          # Production-specific configuration
          
      - name: Pre-production checks
        run: |
          echo "Running pre-production checks..."
          
          # Database backup verification
          echo "Verifying database backup..."
          # Add database backup verification logic
          
          # Resource availability check
          echo "Checking resource availability..."
          # Add resource checks
          
          # Dependencies health check
          echo "Checking dependencies..."
          # Add dependency checks
          
          echo "Pre-production checks completed"

      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."
          echo "Image: ${{ needs.prepare.outputs.image_url }}"
          
          # Production deployment with blue-green or rolling deployment
          cat > docker-compose.production.yml << EOF
          version: '3.8'
          services:
            mysql-graph-visualizer:
              image: ${{ needs.prepare.outputs.image_url }}
              ports:
                - "3000:3000"
                - "8080:8080"
              environment:
                - LOG_LEVEL=warn
                - GO_ENV=production
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/api/health"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 120s
              deploy:
                replicas: 2
                update_config:
                  parallelism: 1
                  delay: 30s
                  order: start-first
                restart_policy:
                  condition: on-failure
                  delay: 5s
                  max_attempts: 3
            
            mysql:
              image: mysql:8.0
              environment:
                MYSQL_ROOT_PASSWORD_FILE: /run/secrets/mysql_root_password
                MYSQL_DATABASE: mysql_graph_visualizer
              volumes:
                - mysql_data:/var/lib/mysql
                - ./mysql/conf.d:/etc/mysql/conf.d:ro
              secrets:
                - mysql_root_password
              restart: unless-stopped
            
            neo4j:
              image: neo4j:4.4
              environment:
                NEO4J_AUTH_FILE: /run/secrets/neo4j_auth
                NEO4J_ACCEPT_LICENSE_AGREEMENT: 'yes'
                NEO4J_dbms_memory_heap_initial__size: 1G
                NEO4J_dbms_memory_heap_max__size: 2G
              ports:
                - "7474:7474"
                - "7687:7687"
              volumes:
                - neo4j_data:/data
                - neo4j_logs:/logs
              secrets:
                - neo4j_auth
              restart: unless-stopped
          
          volumes:
            mysql_data:
            neo4j_data:
            neo4j_logs:
          
          secrets:
            mysql_root_password:
              external: true
            neo4j_auth:
              external: true
          EOF
          
          echo "Production deployment configuration generated"
          
          # Production deployment (customize based on your infrastructure)
          # docker stack deploy -c docker-compose.production.yml mysql-graph-visualizer
          
          echo "Production deployment completed"

      - name: Post-production verification
        run: |
          echo "Verifying production deployment..."
          
          # Extended verification for production
          echo "Waiting for production application to be ready..."
          sleep 120
          
          PRODUCTION_URL="https://mysql-graph-visualizer.example.com"
          
          # Comprehensive health checks
          echo "Running comprehensive health checks..."
          
          # API health check
          if curl -f "$PRODUCTION_URL/api/health" > /dev/null 2>&1; then
            echo "Production API health check passed"
          else
            echo "Production API health check failed"
            exit 1
          fi
          
          # Database connectivity check
          echo "Testing database connectivity..."
          # Add database connectivity tests
          
          # Performance check
          echo "Running performance checks..."
          # Add performance validation
          
          echo "Production deployment verification completed"

  # Rollback capability
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    needs: [prepare, deploy-staging, deploy-production]
    environment:
      name: ${{ needs.prepare.outputs.environment }}-rollback
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Initiate rollback
        run: |
          echo "Initiating rollback for ${{ needs.prepare.outputs.environment }}..."
          
          # Get previous successful deployment
          echo "Finding previous successful deployment..."
          
          # Rollback logic (customize based on your deployment strategy)
          echo "Rolling back to previous version..."
          
          # Example rollback commands
          # docker service rollback mysql-graph-visualizer_mysql-graph-visualizer
          # kubectl rollout undo deployment/mysql-graph-visualizer
          
          echo "Rollback completed"

      - name: Verify rollback
        run: |
          echo "Verifying rollback..."
          
          # Verify rollback was successful
          sleep 60
          
          echo "Rollback verification completed"

  # Post-deployment notifications
  notify:
    name: Deployment Notifications
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging, deploy-production, rollback]
    if: always()
    steps:
      - name: Send deployment notification
        run: |
          ENVIRONMENT="${{ needs.prepare.outputs.environment }}"
          IMAGE_URL="${{ needs.prepare.outputs.image_url }}"
          
          if [[ "${{ needs.deploy-staging.result }}" == "success" ]] || [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            STATUS="SUCCESS"
            MESSAGE="Deployment to $ENVIRONMENT completed successfully!"
          elif [[ "${{ needs.rollback.result }}" == "success" ]]; then
            STATUS="ROLLBACK"
            MESSAGE="Deployment to $ENVIRONMENT failed, but rollback completed successfully."
          else
            STATUS="FAILURE"
            MESSAGE="Deployment to $ENVIRONMENT failed!"
          fi
          
          echo "Deployment Status: $STATUS"
          echo "Environment: $ENVIRONMENT"
          echo "Image: $IMAGE_URL"
          echo "Message: $MESSAGE"
          
          # Add your notification integrations here:
          # - Slack webhook
          # - Discord webhook
          # - Microsoft Teams
          # - Email notifications
          # - PagerDuty alerts
          
          # Example Slack notification (uncomment and configure)
          # if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
          #   curl -X POST -H 'Content-type: application/json' \
          #     --data "{\"text\":\"$MESSAGE\"}" \
          #     "$SLACK_WEBHOOK_URL"
          # fi

  # Update deployment status
  update-status:
    name: Update Deployment Status
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging, deploy-production]
    if: always()
    steps:
      - name: Update deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ needs.prepare.outputs.environment }}';
            const imageUrl = '${{ needs.prepare.outputs.image_url }}';
            const deployResult = environment === 'staging' 
              ? '${{ needs.deploy-staging.result }}' 
              : '${{ needs.deploy-production.result }}';
            
            const status = deployResult === 'success' ? 'success' : 'failure';
            const description = `Deployment to ${environment}: ${deployResult}`;
            
            // Create deployment status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: status,
              description: description,
              environment: environment,
              environment_url: environment === 'production' 
                ? 'https://mysql-graph-visualizer.example.com'
                : 'https://mysql-graph-visualizer-staging.example.com'
            });
            
            console.log(`Deployment status updated: ${status} for ${environment}`);
