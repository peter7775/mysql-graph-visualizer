/*
 * MySQL Graph Visualizer - Integration Tests for Direct Database Connection
 *
 * Copyright (c) 2024
 * Licensed under Dual License: AGPL-3.0 OR Commercial License
 * See LICENSE file for details
 * Patent Pending - Application filed for innovative database transformation techniques
 */

package integration

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"testing"
	"time"

	"mysql-graph-visualizer/internal/application/services"
	"mysql-graph-visualizer/internal/domain/models"
	"mysql-graph-visualizer/internal/infrastructure/persistence/mysql"

	_ "github.com/go-sql-driver/mysql"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

// DirectDatabaseIntegrationTestSuite contains integration tests for direct database connection
type DirectDatabaseIntegrationTestSuite struct {
	suite.Suite
	config     *models.MySQLConfig
	mysqlRepo  *mysql.MySQLRepository
	dbService  *services.DirectDatabaseService
	ctx        context.Context
}

// SetupSuite initializes the test suite with database configuration
func (suite *DirectDatabaseIntegrationTestSuite) SetupSuite() {
	suite.ctx = context.Background()
	
	// Check if integration tests should run
	if os.Getenv("INTEGRATION_TESTS") != "true" {
		suite.T().Skip("Integration tests skipped - set INTEGRATION_TESTS=true to enable")
	}
	
	// Setup configuration for Sakila test database
	suite.config = &models.MySQLConfig{
		Host:           "127.0.0.1",
		Port:           3308,
		Username:       "sakila_user",
		Password:       "sakila123",
		Database:       "sakila",
		ConnectionMode: models.ConnectionModeExisting,
		
		DataFiltering: models.DataFilteringConfig{
			SchemaDiscovery:  true,
			RowLimitPerTable: 100,
			TableBlacklist:   []string{"film_text"}, // Skip full-text table for faster tests
		},
		
		Security: models.SecurityConfig{
			ReadOnly:          true,
			ConnectionTimeout: 30,
			QueryTimeout:      60,
			MaxConnections:    3,
		},
		
		AutoGeneratedRules: models.AutoGeneratedRulesConfig{
			Enabled: true,
			Strategy: &models.RuleGenerationStrategy{
				TableToNode:            true,
				ForeignKeysToRelations: true,
				NamingConvention: &models.NamingConvention{
					NodeTypeFormat:     "Pascal",
					RelationTypeFormat: "UPPER_SNAKE",
				},
			},
		},
	}
	
	// Initialize repository and service
	suite.mysqlRepo = mysql.NewMySQLRepository(nil)
	suite.dbService = services.NewDirectDatabaseService(suite.mysqlRepo, suite.config)
	
	// Validate that test database is available
	err := suite.validateTestDatabase()
	require.NoError(suite.T(), err, "Test database should be available")
}

// validateTestDatabase checks if the test database is running and accessible
func (suite *DirectDatabaseIntegrationTestSuite) validateTestDatabase() error {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s",
		suite.config.Username,
		suite.config.Password,
		suite.config.Host,
		suite.config.Port,
		suite.config.Database,
	)
	
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return fmt.Errorf("failed to open database connection: %w", err)
	}
	defer db.Close()
	
	ctx, cancel := context.WithTimeout(suite.ctx, 5*time.Second)
	defer cancel()
	
	if err := db.PingContext(ctx); err != nil {
		return fmt.Errorf("failed to ping database: %w", err)
	}
	
	return nil
}

// TestConnectionValidation tests basic connection functionality
func (suite *DirectDatabaseIntegrationTestSuite) TestConnectionValidation() {
	suite.Run("ValidConfiguration", func() {
		err := suite.dbService.ValidateConfiguration()
		assert.NoError(suite.T(), err)
	})
	
	suite.Run("QuickConnectionTest", func() {
		result, err := suite.dbService.TestConnection(suite.ctx)
		require.NoError(suite.T(), err)
		require.NotNil(suite.T(), result)
		
		assert.True(suite.T(), result.Success)
		assert.Equal(suite.T(), "sakila", result.DatabaseName)
		assert.Contains(suite.T(), result.ServerVersion, "8.0")
		assert.Contains(suite.T(), result.UserName, "sakila_user")
		assert.Greater(suite.T(), result.TableCount, 10)
	})
	
	suite.Run("DetailedConnectionTest", func() {
		// Test with detailed security validation
		testConfig := *suite.config
		result, err := suite.dbService.TestConnection(suite.ctx)
		require.NoError(suite.T(), err)
		
		assert.True(suite.T(), result.Success)
		assert.Empty(suite.T(), result.SecurityIssues)
	})
}

// TestSchemaAnalysis tests comprehensive schema discovery and analysis
func (suite *DirectDatabaseIntegrationTestSuite) TestSchemaAnalysis() {
	suite.Run("FullSchemaAnalysis", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		require.NotNil(suite.T(), result)
		
		// Validate basic result structure
		assert.True(suite.T(), result.Success)
		assert.Empty(suite.T(), result.ErrorMessage)
		assert.NotNil(suite.T(), result.DatabaseInfo)
		assert.NotNil(suite.T(), result.SchemaAnalysis)
		assert.NotNil(suite.T(), result.Summary)
		
		// Validate database info
		assert.Equal(suite.T(), "sakila", result.DatabaseInfo.Database)
		assert.Equal(suite.T(), 3308, result.DatabaseInfo.Port)
		assert.Contains(suite.T(), result.DatabaseInfo.Version, "8.0")
		
		// Validate schema analysis
		assert.Greater(suite.T(), len(result.SchemaAnalysis.Tables), 10)
		assert.Equal(suite.T(), "sakila", result.SchemaAnalysis.DatabaseName)
		
		// Validate processing time
		assert.Greater(suite.T(), result.ProcessingDuration, time.Millisecond*10)
		assert.Less(suite.T(), result.ProcessingDuration, time.Second*30)
	})
	
	suite.Run("TableDiscovery", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		tables := result.SchemaAnalysis.Tables
		assert.Greater(suite.T(), len(tables), 10)
		
		// Check for expected Sakila tables
		expectedTables := []string{"actor", "film", "customer", "rental", "inventory"}
		foundTables := make(map[string]bool)
		
		for _, table := range tables {
			foundTables[table.Name] = true
		}
		
		for _, expected := range expectedTables {
			assert.True(suite.T(), foundTables[expected], "Expected table %s should be found", expected)
		}
	})
	
	suite.Run("JunctionTableDetection", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		// Find junction tables
		var junctionTables []string
		for _, table := range result.SchemaAnalysis.Tables {
			if table.GraphType == "RELATIONSHIP" {
				junctionTables = append(junctionTables, table.Name)
			}
		}
		
		// Sakila database should have junction tables like film_actor, film_category
		assert.Greater(suite.T(), len(junctionTables), 0, "Should detect junction tables")
		
		// Check for specific known junction tables
		expectedJunctions := []string{"film_actor", "film_category"}
		for _, expected := range expectedJunctions {
			assert.Contains(suite.T(), junctionTables, expected, "Should detect %s as junction table", expected)
		}
	})
	
	suite.Run("GraphPatternRecognition", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		patterns := result.SchemaAnalysis.GraphPatterns
		assert.Greater(suite.T(), len(patterns), 0, "Should identify graph patterns")
		
		// Check for star schema patterns
		var starSchemas int
		for _, pattern := range patterns {
			if pattern.PatternType == "STAR_SCHEMA" {
				starSchemas++
			}
		}
		
		assert.Greater(suite.T(), starSchemas, 0, "Should identify star schema patterns")
	})
}

// TestRuleGeneration tests automatic transformation rule generation
func (suite *DirectDatabaseIntegrationTestSuite) TestRuleGeneration() {
	suite.Run("AutoRuleGeneration", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		rules := result.SchemaAnalysis.GeneratedRules
		assert.Greater(suite.T(), len(rules), 10, "Should generate multiple transformation rules")
		
		// Count different rule types
		var nodeRules, relationshipRules int
		for _, rule := range rules {
			assert.True(suite.T(), rule.AutoGenerated, "Rules should be marked as auto-generated")
			assert.Greater(suite.T(), rule.Confidence, 0.0, "Rules should have confidence scores")
			assert.NotEmpty(suite.T(), rule.CypherQuery, "Rules should have Cypher queries")
			
			switch rule.RuleType {
			case "NODE_CREATION":
				nodeRules++
			case "RELATIONSHIP_CREATION":
				relationshipRules++
			}
		}
		
		assert.Greater(suite.T(), nodeRules, 5, "Should generate multiple node creation rules")
		assert.Greater(suite.T(), relationshipRules, 0, "Should generate relationship creation rules")
		
		// Validate summary matches generated rules
		assert.Equal(suite.T(), len(rules), result.Summary.TotalRules)
		assert.Equal(suite.T(), nodeRules, result.Summary.NodeRules)
		assert.Equal(suite.T(), relationshipRules, result.Summary.RelationshipRules)
	})
	
	suite.Run("CypherQueryValidation", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		for _, rule := range result.SchemaAnalysis.GeneratedRules {
			cypher := rule.CypherQuery
			assert.NotEmpty(suite.T(), cypher, "Cypher query should not be empty")
			
			if rule.RuleType == "NODE_CREATION" {
				assert.Contains(suite.T(), cypher, "CREATE", "Node creation rule should contain CREATE")
			} else if rule.RuleType == "RELATIONSHIP_CREATION" {
				assert.Contains(suite.T(), cypher, "MATCH", "Relationship rule should contain MATCH")
				assert.Contains(suite.T(), cypher, "CREATE", "Relationship rule should contain CREATE")
			}
		}
	})
}

// TestSecurityValidation tests security features and validation
func (suite *DirectDatabaseIntegrationTestSuite) TestSecurityValidation() {
	suite.Run("SecurityLevelValidation", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		securityResult := result.SecurityValidation
		assert.NotNil(suite.T(), securityResult)
		assert.True(suite.T(), securityResult.IsValid)
		assert.NotEmpty(suite.T(), securityResult.SecurityLevel)
		
		// Security level should be reasonable for test environment
		validLevels := []string{"HIGH", "MEDIUM", "LOW"}
		assert.Contains(suite.T(), validLevels, securityResult.SecurityLevel)
	})
	
	suite.Run("PermissionValidation", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		connValidation := result.ConnectionValidation
		assert.NotNil(suite.T(), connValidation)
		assert.True(suite.T(), connValidation.IsValid)
		assert.NotEmpty(suite.T(), connValidation.Permissions)
	})
}

// TestDataFiltering tests data filtering capabilities
func (suite *DirectDatabaseIntegrationTestSuite) TestDataFiltering() {
	suite.Run("TableWhitelist", func() {
		// Create config with table whitelist
		config := *suite.config
		config.DataFiltering.TableWhitelist = []string{"actor", "film", "customer"}
		
		dbService := services.NewDirectDatabaseService(suite.mysqlRepo, &config)
		result, err := dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		// Should only analyze whitelisted tables
		assert.LessOrEqual(suite.T(), len(result.SchemaAnalysis.Tables), 3)
		
		tableNames := make([]string, 0, len(result.SchemaAnalysis.Tables))
		for _, table := range result.SchemaAnalysis.Tables {
			tableNames = append(tableNames, table.Name)
		}
		
		for _, tableName := range tableNames {
			assert.Contains(suite.T(), config.DataFiltering.TableWhitelist, tableName,
				"Table %s should be in whitelist", tableName)
		}
	})
	
	suite.Run("TableBlacklist", func() {
		// Create config with table blacklist
		config := *suite.config
		config.DataFiltering.TableBlacklist = []string{"film_text", "customer_list", "nicer_but_slower_film_list"}
		
		dbService := services.NewDirectDatabaseService(suite.mysqlRepo, &config)
		result, err := dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		// Should not analyze blacklisted tables
		for _, table := range result.SchemaAnalysis.Tables {
			assert.NotContains(suite.T(), config.DataFiltering.TableBlacklist, table.Name,
				"Table %s should not be in results (blacklisted)", table.Name)
		}
	})
	
	suite.Run("RowLimit", func() {
		// Create config with very small row limit
		config := *suite.config
		config.DataFiltering.RowLimitPerTable = 10
		
		dbService := services.NewDirectDatabaseService(suite.mysqlRepo, &config)
		result, err := dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		
		// Check that row limits are respected in dataset info
		if result.SchemaAnalysis.DatasetInfo != nil {
			for tableName, rowCount := range result.SchemaAnalysis.DatasetInfo.TableSizes {
				assert.LessOrEqual(suite.T(), rowCount, int64(10),
					"Table %s should respect row limit", tableName)
			}
		}
	})
}

// TestPerformance tests performance characteristics
func (suite *DirectDatabaseIntegrationTestSuite) TestPerformance() {
	suite.Run("AnalysisPerformance", func() {
		start := time.Now()
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		duration := time.Since(start)
		
		require.NoError(suite.T(), err)
		assert.True(suite.T(), result.Success)
		
		// Analysis should complete within reasonable time
		assert.Less(suite.T(), duration, 30*time.Second, "Analysis should complete within 30 seconds")
		
		// Processing duration should be tracked correctly
		assert.Greater(suite.T(), result.ProcessingDuration, time.Millisecond*10)
		assert.LessOrEqual(suite.T(), result.ProcessingDuration, duration)
	})
	
	suite.Run("ConnectionTestPerformance", func() {
		start := time.Now()
		result, err := suite.dbService.TestConnection(suite.ctx)
		duration := time.Since(start)
		
		require.NoError(suite.T(), err)
		assert.True(suite.T(), result.Success)
		
		// Connection test should be fast
		assert.Less(suite.T(), duration, 5*time.Second, "Connection test should complete within 5 seconds")
	})
}

// TestErrorHandling tests error handling and edge cases
func (suite *DirectDatabaseIntegrationTestSuite) TestErrorHandling() {
	suite.Run("InvalidCredentials", func() {
		config := *suite.config
		config.Password = "invalid_password"
		
		dbService := services.NewDirectDatabaseService(suite.mysqlRepo, &config)
		result, err := dbService.TestConnection(suite.ctx)
		
		// Should handle error gracefully
		require.NoError(suite.T(), err)
		require.NotNil(suite.T(), result)
		assert.False(suite.T(), result.Success)
		assert.NotEmpty(suite.T(), result.ErrorMessage)
	})
	
	suite.Run("InvalidHost", func() {
		config := *suite.config
		config.Host = "nonexistent-host.local"
		
		dbService := services.NewDirectDatabaseService(suite.mysqlRepo, &config)
		result, err := dbService.TestConnection(suite.ctx)
		
		// Should handle error gracefully
		require.NoError(suite.T(), err)
		require.NotNil(suite.T(), result)
		assert.False(suite.T(), result.Success)
		assert.NotEmpty(suite.T(), result.ErrorMessage)
	})
	
	suite.Run("ShortTimeout", func() {
		config := *suite.config
		config.Security.ConnectionTimeout = 1 // Very short timeout
		
		dbService := services.NewDirectDatabaseService(suite.mysqlRepo, &config)
		ctx, cancel := context.WithTimeout(suite.ctx, 2*time.Second)
		defer cancel()
		
		// Should handle timeout gracefully
		_, err := dbService.TestConnection(ctx)
		// Error handling may vary, but should not panic
		if err != nil {
			assert.NotEmpty(suite.T(), err.Error())
		}
	})
}

// TestDataSizeEstimation tests dataset size estimation functionality
func (suite *DirectDatabaseIntegrationTestSuite) TestDataSizeEstimation() {
	suite.Run("SizeEstimation", func() {
		datasetInfo, err := suite.dbService.GetDataSizeEstimation(suite.ctx)
		require.NoError(suite.T(), err)
		require.NotNil(suite.T(), datasetInfo)
		
		assert.Greater(suite.T(), datasetInfo.TotalTables, 0)
		assert.Greater(suite.T(), datasetInfo.TotalRows, int64(0))
		assert.Greater(suite.T(), datasetInfo.EstimatedSizeMB, 0.0)
		assert.NotEmpty(suite.T(), datasetInfo.TableSizes)
	})
}

// TestConfigurationValidation tests configuration validation
func (suite *DirectDatabaseIntegrationTestSuite) TestConfigurationValidation() {
	suite.Run("ValidConfiguration", func() {
		err := suite.dbService.ValidateConfiguration()
		assert.NoError(suite.T(), err)
	})
	
	suite.Run("InvalidConfiguration", func() {
		// Test with missing required fields
		invalidConfigs := []*models.MySQLConfig{
			{Host: "", Database: "test"}, // Missing host
			{Host: "localhost", Database: ""}, // Missing database
			{Host: "localhost", Database: "test", Username: ""}, // Missing username
		}
		
		for _, config := range invalidConfigs {
			dbService := services.NewDirectDatabaseService(suite.mysqlRepo, config)
			err := dbService.ValidateConfiguration()
			assert.Error(suite.T(), err, "Should reject invalid configuration")
		}
	})
}

// TestConcurrentAccess tests concurrent operations
func (suite *DirectDatabaseIntegrationTestSuite) TestConcurrentAccess() {
	suite.Run("ConcurrentConnectionTests", func() {
		const numConcurrent = 3
		
		results := make(chan error, numConcurrent)
		
		for i := 0; i < numConcurrent; i++ {
			go func() {
				result, err := suite.dbService.TestConnection(suite.ctx)
				if err != nil {
					results <- err
					return
				}
				if !result.Success {
					results <- fmt.Errorf("connection test failed: %s", result.ErrorMessage)
					return
				}
				results <- nil
			}()
		}
		
		// Wait for all goroutines to complete
		for i := 0; i < numConcurrent; i++ {
			err := <-results
			assert.NoError(suite.T(), err, "Concurrent connection test should succeed")
		}
	})
}

// TestSuite runs all integration tests
func TestDirectDatabaseIntegration(t *testing.T) {
	suite.Run(t, new(DirectDatabaseIntegrationTestSuite))
}

// BenchmarkAnalysisPerformance benchmarks the analysis performance
func BenchmarkAnalysisPerformance(b *testing.B) {
	if os.Getenv("INTEGRATION_TESTS") != "true" {
		b.Skip("Integration tests skipped - set INTEGRATION_TESTS=true to enable")
	}
	
	// Setup
	config := &models.MySQLConfig{
		Host:           "127.0.0.1",
		Port:           3308,
		Username:       "sakila_user",
		Password:       "sakila123",
		Database:       "sakila",
		ConnectionMode: models.ConnectionModeExisting,
		
		DataFiltering: models.DataFilteringConfig{
			SchemaDiscovery:  true,
			RowLimitPerTable: 50, // Small limit for benchmark
		},
		
		Security: models.SecurityConfig{
			ReadOnly:          true,
			ConnectionTimeout: 30,
			QueryTimeout:      60,
			MaxConnections:    3,
		},
		
		AutoGeneratedRules: models.AutoGeneratedRulesConfig{
			Enabled: true,
			Strategy: &models.RuleGenerationStrategy{
				TableToNode:            true,
				ForeignKeysToRelations: true,
			},
		},
	}
	
	mysqlRepo := mysql.NewMySQLRepository(nil)
	dbService := services.NewDirectDatabaseService(mysqlRepo, config)
	ctx := context.Background()
	
	b.ResetTimer()
	
	for i := 0; i < b.N; i++ {
		result, err := dbService.ConnectAndAnalyze(ctx)
		if err != nil {
			b.Fatalf("Analysis failed: %v", err)
		}
		if !result.Success {
			b.Fatalf("Analysis unsuccessful: %s", result.ErrorMessage)
		}
	}
}
